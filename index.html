<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Live Strategy Advisor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
    body { font-family: 'Inter', sans-serif; background-color: #09090b; color: #ffffff; }

    /* Animations */
    @keyframes pulse-green {
      0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.4); border-color: rgba(74, 222, 128, 0.8); }
      50% { box-shadow: 0 0 15px 0 rgba(74, 222, 128, 0.2); border-color: rgba(74, 222, 128, 1); }
    }
    
    @keyframes pulse-gold {
      0%, 100% { box-shadow: 0 0 0 0 rgba(234, 179, 8, 0.4); border-color: rgba(234, 179, 8, 0.8); }
      50% { box-shadow: 0 0 15px 0 rgba(234, 179, 8, 0.2); border-color: rgba(234, 179, 8, 1); }
    }

    .slot-container {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      background: #18181b;
    }

    /* Hints */
    .slot-best {
      animation: pulse-green 2s infinite;
      background: rgba(22, 101, 52, 0.1);
      border-width: 2px;
    }
    .slot-tie {
      animation: pulse-gold 2s infinite;
      background: rgba(161, 98, 7, 0.1);
      border-width: 2px;
    }
    
    .slot-valid { border-color: #3f3f46; }
    .slot-bad { opacity: 0.5; background: rgba(127, 29, 29, 0.1); border-color: #450a0a; }
    .slot-invalid { opacity: 0.2; pointer-events: none; background: #000; border-color: #27272a; }
    
    .number-btn { transition: all 0.15s; }
    .number-btn:active { transform: scale(0.95); }
    .number-btn.used {
      opacity: 0.2; pointer-events: none; background: #000; border-color: #27272a; text-decoration: line-through;
    }
    .number-btn.active-card {
      background-color: #4f46e5; border-color: #818cf8; color: white;
      transform: scale(1.1); box-shadow: 0 0 20px rgba(79, 70, 229, 0.4);
    }

    .placed-chip { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    /* Strategy Table Styles */
    .strategy-row { border-bottom: 1px solid #27272a; }
    .strategy-row:last-child { border-bottom: none; }
    .strategy-card-pill {
      background: #3f3f46; color: #e4e4e7; font-weight: 700;
      padding: 2px 8px; border-radius: 999px; font-size: 0.75rem;
    }
  </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4 pb-20">

  <!-- Header / Stats -->
  <header class="text-center mb-6 w-full max-w-lg">
    <div class="flex justify-between items-end mb-4 border-b border-zinc-800 pb-4">
      <button onclick="resetGame()" class="bg-zinc-800 hover:bg-zinc-700 text-xs px-3 py-1.5 rounded text-zinc-300 transition-colors border border-zinc-700">
        Reset
      </button>
    </div>

    <div class="bg-zinc-900/50 border border-zinc-800 rounded-2xl p-6 shadow-2xl backdrop-blur-sm relative overflow-hidden">
      <div id="glow-bg" class="absolute inset-0 opacity-10 bg-indigo-500 transition-opacity duration-500"></div>
      <div class="relative z-10">
        <div class="text-[10px] text-zinc-500 uppercase tracking-widest font-bold mb-1">WIN PROBABILITY</div>
        <div id="prob-display" class="text-5xl font-black text-white tracking-tighter tabular-nums transition-colors duration-300">
          33.60%
        </div>
        <div id="guidance-text" class="text-zinc-400 text-xs font-mono mt-2 h-4">
          Select a card...
        </div>
      </div>
    </div>
  </header>

  <!-- Game Board -->
  <div class="w-full max-w-lg mb-6">
    <div class="grid grid-cols-5 gap-2" id="board-area"></div>
  </div>

  <!-- Controls -->
  <div class="w-full max-w-lg mb-8">
    <div class="text-[10px] text-zinc-500 uppercase tracking-widest font-bold mb-3 text-center">SELECT DRAWN CARD</div>
    <div class="grid grid-cols-5 gap-2" id="number-pad"></div>
  </div>

  <!-- FUTURE STRATEGY TABLE -->
  <div class="w-full max-w-lg">
    <div class="bg-zinc-900 border border-zinc-800 rounded-2xl overflow-hidden">
      <div class="bg-zinc-800/50 px-4 py-3 border-b border-zinc-800 flex justify-between items-center">
        <span class="text-xs font-bold text-indigo-400 uppercase tracking-wider">Future Strategy</span>
        <span class="text-[10px] text-zinc-500">Best slots for remaining cards</span>
      </div>
      <div id="strategy-table-body" class="p-0">
        <!-- JS will populate -->
        <div class="p-4 text-center text-xs text-zinc-500">Loading...</div>
      </div>
    </div>
  </div>

  <script>
    // --- SETTINGS ---
    const NUM_SLOTS = 5;
    const NUM_CARDS = 10;
    const SLOT_NAMES = ['A', 'B', 'C', 'D', 'E'];
    const EPS = 1e-9; 

    // --- STATE ---
    let board = new Int8Array(NUM_SLOTS).fill(0);
    let seenMask = 0;
    let activeCard = null; 
    let memo = new Map();

    function init() {
      renderSlots();
      renderNumberPad();
      updateWinProbability();
      updateStrategyGuide();
    }

    // --- CORE CALCULATION (DP / EXPECTIMAX) ---
    function getMemoKey(currentBoard, mask) {
        return mask + ":" + currentBoard.join(',');
    }

    function solve(currentBoard, mask) {
        // Validity Check
        let filled = 0;
        let lastVal = 0;
        let isSorted = true;
        
        for(let i=0; i<NUM_SLOTS; i++) {
            if (currentBoard[i] !== 0) {
                filled++;
                if (currentBoard[i] < lastVal) isSorted = false;
                lastVal = currentBoard[i];
            }
        }

        if (!isSorted) return 0.0;
        if (filled === NUM_SLOTS) return 1.0;

        const key = getMemoKey(currentBoard, mask);
        if (memo.has(key)) return memo.get(key);

        let totalProb = 0.0;
        let remainingCount = 0;

        for (let card = 1; card <= NUM_CARDS; card++) {
            if (!((mask >> (card - 1)) & 1)) { 
                remainingCount++;
                let bestMoveProb = 0.0;
                
                for (let i = 0; i < NUM_SLOTS; i++) {
                    if (currentBoard[i] === 0) {
                        // Validity Test
                        let valid = true;
                        for (let l = 0; l < i; l++) if (currentBoard[l] !== 0 && currentBoard[l] > card) { valid = false; break; }
                        if (valid) {
                            for (let r = i + 1; r < NUM_SLOTS; r++) if (currentBoard[r] !== 0 && currentBoard[r] < card) { valid = false; break; }
                        }

                        if (valid) {
                            let nextBoard = new Int8Array(currentBoard);
                            nextBoard[i] = card;
                            let prob = solve(nextBoard, mask | (1 << (card - 1)));
                            if (prob > bestMoveProb) bestMoveProb = prob;
                            if (bestMoveProb >= (1.0 - EPS)) break; 
                        }
                    }
                }
                totalProb += bestMoveProb;
            }
        }

        if (remainingCount === 0) return 0.0; 
        const result = totalProb / remainingCount;
        memo.set(key, result);
        return result;
    }

    // --- NEW: FUTURE STRATEGY CALCULATOR ---
    function updateStrategyGuide() {
        const tableBody = document.getElementById('strategy-table-body');
        
        // 1. Find remaining cards
        let remainingCards = [];
        for (let c = 1; c <= NUM_CARDS; c++) {
            if (!((seenMask >> (c - 1)) & 1)) remainingCards.push(c);
        }

        if (remainingCards.length === 0) {
            tableBody.innerHTML = '<div class="p-4 text-center text-xs text-green-500">Game Over!</div>';
            return;
        }

        // 2. Find best slot for each remaining card
        // slotMap[slotIndex] = [card, card, ...]
        let slotMap = Array(NUM_SLOTS).fill().map(() => []);
        let unplayableCards = [];

        remainingCards.forEach(card => {
            let bestProb = -1.0;
            let bestSlots = [];

            // If this card were drawn, where would we put it?
            for (let i = 0; i < NUM_SLOTS; i++) {
                if (board[i] === 0) {
                    // Validity check
                    let valid = true;
                    for (let l = 0; l < i; l++) if (board[l] !== 0 && board[l] > card) valid = false;
                    for (let r = i + 1; r < NUM_SLOTS; r++) if (board[r] !== 0 && board[r] < card) valid = false;
                    
                    if (valid) {
                        let nextBoard = new Int8Array(board);
                        nextBoard[i] = card;
                        let prob = solve(nextBoard, seenMask | (1 << (card - 1)));
                        
                        if (Math.abs(prob - bestProb) < EPS) {
                            bestSlots.push(i);
                        } else if (prob > bestProb) {
                            bestProb = prob;
                            bestSlots = [i];
                        }
                    }
                }
            }

            if (bestProb < EPS) {
                unplayableCards.push(card);
            } else {
                // Recommend only the first optimal slot for simplicity
                slotMap[bestSlots[0]].push(card);
            }
        });

        // 3. Draw Table
        let html = '';
        
        // Iterate slots
        SLOT_NAMES.forEach((name, idx) => {
            // Show if slot is empty and has recommended cards
            if (board[idx] === 0 && slotMap[idx].length > 0) {
                const cardsHtml = slotMap[idx].map(c => 
                    `<span class="strategy-card-pill border border-zinc-600">${c}</span>`
                ).join(' ');

                html += `
                <div class="strategy-row flex items-center px-4 py-3 hover:bg-zinc-800/30 transition-colors">
                    <div class="w-12 text-sm font-bold text-zinc-400">Slot ${name}</div>
                    <div class="flex-1 flex flex-wrap gap-2">
                        <span class="text-xs text-zinc-500 mr-2 self-center">If drawn:</span>
                        ${cardsHtml}
                    </div>
                </div>`;
            }
        });

        if (unplayableCards.length > 0) {
             const deadHtml = unplayableCards.map(c => `<span class="strategy-card-pill bg-red-900/50 text-red-200 border-red-900">${c}</span>`).join(' ');
             html += `
                <div class="strategy-row flex items-center px-4 py-3 bg-red-900/10">
                    <div class="w-12 text-sm font-bold text-red-500">Doom</div>
                    <div class="flex-1 flex flex-wrap gap-2">
                        <span class="text-xs text-red-400 mr-2 self-center">Loses Game:</span>
                        ${deadHtml}
                    </div>
                </div>`;
        }

        if (html === '') {
             html = '<div class="p-4 text-center text-xs text-zinc-500">No winning path.</div>';
        }

        tableBody.innerHTML = html;
    }

    // --- UI FUNCTIONS ---

    function renderSlots() {
      const container = document.getElementById('board-area');
      container.innerHTML = '';
      
      board.forEach((val, index) => {
        const div = document.createElement('div');
        div.className = `slot-container flex flex-col items-center justify-center border border-zinc-800 rounded-xl h-24 relative cursor-pointer`;
        div.onclick = () => handleSlotClick(index);

        div.innerHTML = `<div class="text-zinc-700 text-[10px] font-bold absolute top-2">${SLOT_NAMES[index]}</div>`;

        if (val !== 0) {
           const chip = document.createElement('div');
           chip.className = `placed-chip w-10 h-10 rounded-full flex items-center justify-center font-bold text-white shadow-lg ${
             val === 1 || val === 10 ? 'bg-indigo-600' : 'bg-zinc-700'
           }`;
           chip.textContent = val;
           div.appendChild(chip);
           div.classList.add('border-zinc-700');
        } else {
            const hint = document.createElement('div');
            hint.className = "hint-text text-xs font-mono font-bold";
            div.appendChild(hint);
        }
        container.appendChild(div);
      });
    }

    function renderNumberPad() {
      const container = document.getElementById('number-pad');
      container.innerHTML = '';
      
      for (let i = 1; i <= NUM_CARDS; i++) {
        const btn = document.createElement('button');
        const isUsed = (seenMask >> (i - 1)) & 1;
        btn.className = `number-btn w-full h-10 rounded-lg border font-bold text-sm ${
          isUsed ? 'used text-zinc-600 border-zinc-800 bg-black' : 'text-zinc-300 border-zinc-700 bg-zinc-800 hover:bg-zinc-700'
        }`;
        if (activeCard === i) btn.classList.add('active-card');
        btn.textContent = i;
        btn.onclick = () => selectCard(i);
        container.appendChild(btn);
      }
    }

    function selectCard(num) {
        if ((seenMask >> (num - 1)) & 1) return;
        activeCard = (activeCard === num) ? null : num;
        renderNumberPad();
        calculateBestMovesForActiveCard();
    }

    function handleSlotClick(slotIndex) {
        if (activeCard === null) return;
        if (board[slotIndex] !== 0) return;

        // Local Validation
        for (let l = 0; l < slotIndex; l++) if (board[l] !== 0 && board[l] > activeCard) { shakeBoard(); return; }
        for (let r = slotIndex + 1; r < NUM_SLOTS; r++) if (board[r] !== 0 && board[r] < activeCard) { shakeBoard(); return; }

        // Make Move
        board[slotIndex] = activeCard;
        seenMask |= (1 << (activeCard - 1));
        activeCard = null;

        renderSlots();
        renderNumberPad();
        updateWinProbability();
        updateStrategyGuide(); 
    }

    function calculateBestMovesForActiveCard() {
        const slots = document.querySelectorAll('.slot-container');
        const hintText = document.getElementById('guidance-text');
        
        // Reset Styles Safely
        slots.forEach((s, index) => {
            const isFilled = board[index] !== 0;

            let baseClass = `slot-container flex flex-col items-center justify-center border border-zinc-800 rounded-xl h-24 relative cursor-pointer`;
            if (isFilled) baseClass += ' border-zinc-700';
            s.className = baseClass;

            const hintEl = s.querySelector('.hint-text');
            if (hintEl) {
                hintEl.textContent = '';
                hintEl.className = 'hint-text text-xs font-mono font-bold hidden';
            }
        });

        if (activeCard === null) {
            hintText.textContent = "Select a card...";
            hintText.className = "text-zinc-400 text-xs font-mono mt-2 h-4";
            return;
        }

        let moves = [];
        let maxProb = -1.0;

        for (let i = 0; i < NUM_SLOTS; i++) {
            if (board[i] !== 0) { moves.push({ index: i, type: 'filled', prob: 0 }); continue; }

            let valid = true;
            for (let l = 0; l < i; l++) if (board[l] !== 0 && board[l] > activeCard) valid = false;
            for (let r = i + 1; r < NUM_SLOTS; r++) if (board[r] !== 0 && board[r] < activeCard) valid = false;

            if (!valid) {
                moves.push({ index: i, type: 'invalid', prob: 0 });
            } else {
                let nextBoard = new Int8Array(board);
                nextBoard[i] = activeCard;
                let prob = solve(nextBoard, seenMask | (1 << (activeCard - 1)));
                moves.push({ index: i, type: 'valid', prob: prob });
                if (prob > maxProb) maxProb = prob;
            }
        }

        moves.forEach(m => {
            const el = slots[m.index];
            const hintEl = el.querySelector('.hint-text');

            if (m.type === 'filled') return;
            
            if (m.type === 'invalid') {
                el.classList.add('slot-invalid');
            } else {
                if (hintEl) {
                    hintEl.classList.remove('hidden');
                    hintEl.textContent = (m.prob * 100).toFixed(0) + '%';
                    
                    if (Math.abs(m.prob - maxProb) < EPS && maxProb > EPS) {
                        el.classList.add('slot-best', 'border-green-500');
                        hintEl.classList.add('text-green-400');
                    } else if (m.prob < EPS) {
                        el.classList.add('slot-bad');
                    } else {
                        el.classList.add('slot-valid');
                        hintEl.classList.add('text-zinc-500');
                    }
                }
            }
        });
        
        if (maxProb < EPS) {
             hintText.textContent = "No winning moves.";
             hintText.className = "text-red-500 text-xs font-mono mt-2 h-4";
        } else {
             hintText.textContent = `Best outcome: ${(maxProb * 100).toFixed(1)}%`;
             hintText.className = "text-green-400 text-xs font-mono mt-2 h-4";
        }
    }

    function updateWinProbability() {
        const prob = solve(board, seenMask);
        const display = document.getElementById('prob-display');
        const glow = document.getElementById('glow-bg');
        
        display.textContent = (prob * 100).toFixed(2) + '%';
        
        if (prob > 0.5) {
            display.className = "text-5xl font-black text-green-400 tracking-tighter tabular-nums transition-colors duration-300";
            glow.className = "absolute inset-0 opacity-20 bg-green-500 transition-opacity duration-500";
        } else if (prob > 0.1) {
            display.className = "text-5xl font-black text-indigo-400 tracking-tighter tabular-nums transition-colors duration-300";
            glow.className = "absolute inset-0 opacity-10 bg-indigo-500 transition-opacity duration-500";
        } else {
            display.className = "text-5xl font-black text-red-500 tracking-tighter tabular-nums transition-colors duration-300";
            glow.className = "absolute inset-0 opacity-10 bg-red-500 transition-opacity duration-500";
        }
    }

    function resetGame() {
        board = new Int8Array(NUM_SLOTS).fill(0);
        seenMask = 0;
        activeCard = null;
        memo.clear();
        renderSlots();
        renderNumberPad();
        updateWinProbability();
        updateStrategyGuide();
    }

    function shakeBoard() {
        const boardEl = document.getElementById('board-area');
        boardEl.style.transform = "translateX(5px)";
        setTimeout(() => boardEl.style.transform = "translateX(-5px)", 50);
        setTimeout(() => boardEl.style.transform = "translateX(5px)", 100);
        setTimeout(() => boardEl.style.transform = "translateX(0)", 150);
    }

    init();
  </script>
</body>
</html>
